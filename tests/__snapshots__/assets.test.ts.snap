// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Asset Integrity (Golden Tests) > should match Isolate SDK snapshot 1`] = `
"// Generated SDK for isolated-vm
const __allowedTools = ["test__*","github__*"];
const _tools = {
  test: {
    async hello(args) {
      const resStr = await __callTool("test__hello", JSON.stringify(args || {}));
      return JSON.parse(resStr);
    },
  },
  github: {
    async create_issue(args) {
      const resStr = await __callTool("github__create_issue", JSON.stringify(args || {}));
      return JSON.parse(resStr);
    },
  },
  async $raw(name, args) {
    const normalized = name.replace(/\\./g, '__');
    if (__allowedTools) {
      const allowed = __allowedTools.some(p => {
        if (p.endsWith('__*')) return normalized.startsWith(p.slice(0, -1));
        return normalized === p;
      });
      if (!allowed) throw new Error(\`Tool \${name} is not in the allowlist\`);
    }
    const resStr = await __callTool(normalized, JSON.stringify(args || {}));
    return JSON.parse(resStr);
  },
};

const tools = new Proxy(_tools, {
    get: (target, prop) => {
        if (prop in target) return target[prop];
        if (prop === 'then') return undefined;
        if (typeof prop === 'string') {
            // Flat tool access fallback: search all namespaces for a matching tool
            for (const nsName of Object.keys(target)) {
                if (nsName === '$raw') continue;
                const ns = target[nsName];
                if (ns && typeof ns === 'object' && ns[prop]) {
                    return ns[prop];
                }
            }

            const forbidden = ['$raw'];
            const namespaces = Object.keys(target).filter(k => !forbidden.includes(k));
            throw new Error(\`Namespace or Tool '\${prop}' not found. Available namespaces: \${namespaces.join(', ') || 'none'}. Use tools.$raw(name, args) for dynamic calls.\`);
        }
        return undefined;
    }
});
"
`;

exports[`Asset Integrity (Golden Tests) > should match Python SDK snapshot 1`] = `
"# Generated SDK - Do not edit
_allowed_tools = ["test__*","github__*"]

class _test_Namespace:
    async def hello(self, args=None, **kwargs):
        params = args if args is not None else kwargs
        return await _internal_call_tool("test__hello", params)

class _github_Namespace:
    async def create_issue(self, args=None, **kwargs):
        params = args if args is not None else kwargs
        return await _internal_call_tool("github__create_issue", params)

class _Tools:
    def __init__(self):
        self.test = _test_Namespace()
        self.github = _github_Namespace()

    def __getattr__(self, name):
        # Flat access fallback: search all namespaces
        for attr_name in dir(self):
            attr = getattr(self, attr_name, None)
            if attr and hasattr(attr, name):
                return getattr(attr, name)
        raise AttributeError(f"Namespace or Tool '{name}' not found")

    async def raw(self, name, args=None):
        """Call a tool by its full name (escape hatch for dynamic/unknown tools)"""
        normalized = name.replace(".", "__")
        if _allowed_tools is not None:
            allowed = any(
                normalized.startswith(p[:-1]) if p.endswith("__*") else normalized == p
                for p in _allowed_tools
            )
            if not allowed:
                raise PermissionError(f"Tool {name} is not in the allowlist")
        return await _internal_call_tool(normalized, args or {})

tools = _Tools()"
`;

exports[`Asset Integrity (Golden Tests) > should match TypeScript SDK snapshot 1`] = `
"// Generated SDK - Do not edit
const __allowedTools = ["test__*","github__*"];
const _tools = {
  test: {
    /** Returns a greeting */
    async hello(args) {
      return await __internalCallTool("test__hello", args);
    },
  },
  github: {
    /** Creates a GitHub issue */
    async create_issue(args) {
      return await __internalCallTool("github__create_issue", args);
    },
  },
  /** Call a tool by its full name (escape hatch for dynamic/unknown tools) */
  async $raw(name, args) {
    const normalized = name.replace(/\\./g, '__');
    if (__allowedTools) {
      const allowed = __allowedTools.some(p => {
        if (p.endsWith('__*')) return normalized.startsWith(p.slice(0, -1));
        return normalized === p;
      });
      if (!allowed) throw new Error(\`Tool \${name} is not in the allowlist\`);
    }
    return await __internalCallTool(normalized, args);
  },
};

const tools = new Proxy(_tools, {
    get: (target, prop) => {
        if (prop in target) return target[prop];
        if (prop === 'then') return undefined;
        if (typeof prop === 'string') {
            // Flat tool access fallback: search all namespaces for a matching tool
            for (const nsName of Object.keys(target)) {
                if (nsName === '$raw') continue;
                const ns = target[nsName];
                if (ns && typeof ns === 'object' && ns[prop]) {
                    return ns[prop];
                }
            }

            const forbidden = ['$raw'];
            const namespaces = Object.keys(target).filter(k => !forbidden.includes(k));
            throw new Error(\`Namespace or Tool '\${prop}' not found. Available namespaces: \${namespaces.join(', ') || 'none'}. Use tools.$raw(name, args) for dynamic calls.\`);
        }
        return undefined;
    }
});

(globalThis as any).tools = tools;"
`;
